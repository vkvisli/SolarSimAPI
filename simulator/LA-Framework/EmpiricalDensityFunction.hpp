// ****************************************************************************
// Empirical Density Function
//
// The empirical density function is basically a frequency table. Consider
// the following example of three symbols and their counted frequency in 
// a sample.
// 
//  A	40
//  B	25
//  C 35
//
// Since the total sum is 100, the relative frequencies are 0.4, 0.25 and 
// 0.35 respectively. Thus random symbols generated by the distribution 
// should reflect these relative probabilities defined by the frequency
// table given to the constructor. 
//
// The frequencies can be stored in any structure that has iterators,
// and supports the iterator traits mechanism for reporting the value 
// type. The only requirement is that the frequency type supports a static cast
// to a double.
//
// Author: Geir Horn, 2011-2014
// Lisence: LGPL 3.0
// Geir Horn, 2017: Deprecated by the Random::Index function
//
// ****************************************************************************

#ifndef EMPIRICAL_DENSITY_FUNCTION
#define EMPIRICAL_DENSITY_FUNCTION

#include <list>
#include <vector>
#include <iterator>

#include "RandomGenerator.hpp"

// The original version of this code had a template constructor. This worked
// fine with VisualStudio, but not with g++. The code has therefore been 
// slightly modified to take the iterators as template parameters and then
// deduce the symbol type from the iterators.

template< class FrequencyIterator, class SymbolIterator >
class [[deprecated("Empirical Density Function is replaced by Random::Index")]]
EmpiricalDensityFunction
{
private:
    // The symbol type can be deduced from the symbol iterator

    typedef 
    typename std::iterator_traits< SymbolIterator >::value_type SymbolType;
    
    // First a struct to bind the symbol to the relative frequency so that
    // the symbol to return can quickly be found by one pass over the 
    // list of frequencies.

    class FrequencySymbols
    {
    public:
	double	   Frequency;
	SymbolType Symbol;

	FrequencySymbols( double TheFrequency, SymbolType TheSymbol )
	{
	    Frequency = TheFrequency;
	    Symbol    = TheSymbol;
	};
    };

    // The relative frequencies are stored in a list since it will always
    // be searched from the start for the symbol corresponding to the 
    // random frequency drawn.

    std::list < FrequencySymbols > CummulativeFrequencies;

public:

    // There is only one constructor taking a start and end iterator for the
    // values and an iterator for the symbols. It is assumed that there is as
    // many symbols as there are values for the frequencies.

    //template< class FrequencyIterator, class SymbolIterator > // Old constructor header
    EmpiricalDensityFunction ( FrequencyIterator FrequencyStart,
			       FrequencyIterator FrequencyEnd,
			       SymbolIterator	 Symbols        )
		: CummulativeFrequencies()
    {
	// First pass is to record the cumulative sum of frequencies, 
	// and the corresponding symbols

	double TotalFrequencies = 0; 

	for ( FrequencyIterator Value = FrequencyStart;
	      Value != FrequencyEnd; Value++, Symbols++ )
	{
	  TotalFrequencies += static_cast<double>( *Value );
	  CummulativeFrequencies.push_back(
		  FrequencySymbols( TotalFrequencies, *Symbols ) );
	}
	
	// The second pass will normalise the frequencies to values
	// in the range 0..1 by dividing all on the total frequencies.

	for ( FrequencySymbols & Record : CummulativeFrequencies )
	    Record.Frequency = Record.Frequency / TotalFrequencies;
    };

    // To return a random symbol, one will first have to draw a random value 
    // between zero and unity, and then step through the cumulative 
    // frequencies until one finds one whose value is larger or equal to
    // the drawn random value. Given that the last cumulative sum is 
    // always unity, this search will always terminate successfully.
    
    SymbolType Random( void )
    {
	double RandomValue = Random::Number();
	auto   Candidate   = CummulativeFrequencies.begin();

	while ( Candidate->Frequency < RandomValue ) Candidate++;

	return Candidate->Symbol;
    };
	
    // And the operator does the same to give a second interface to the 
    // random function
    
    SymbolType operator () (void)
    {
      return this->Random();
    };
};

// The most convenient way to hide the complexities of the templates is to use
// a generator function to return the density function with the right parameters
//
// auto MyGenerator = EDF( Freq.begin(), Freq.end(), Symb.begin() );

template< class FrequencyIterator, class SymbolIterator >
[[deprecated("Empirical Density Function is replaced by Random::Index")]]
auto EDF ( FrequencyIterator FrequencyStart,
	   FrequencyIterator FrequencyEnd,
	   SymbolIterator    Symbols        )
-> EmpiricalDensityFunction< FrequencyIterator, SymbolIterator >
{
  return 
  EmpiricalDensityFunction< FrequencyIterator, SymbolIterator >
	( FrequencyStart, FrequencyEnd, Symbols );
};

// There is a variant where the symbols are just integers from a given range
// in this case the symbol iterator need not be given and the generator will
// automatically add these as unsigned integers in the range 0..n-1 so that
// the symbols can be used as vector indices.

template< class FrequencyIterator >
[[deprecated("Empirical Density Function is replaced by Random::Index")]]
auto EDF ( FrequencyIterator FrequencyStart,
	   FrequencyIterator FrequencyEnd  )
-> EmpiricalDensityFunction< FrequencyIterator, 
			     std::vector<unsigned int>::iterator >
{
  std::vector< unsigned int > Symbols;
  unsigned int 		 Index = 0;
  
  for ( FrequencyIterator Counter  = FrequencyStart;
			  Counter != FrequencyEnd;
			++Counter )
    Symbols.push_back( Index++ );
  
  return 
  EmpiricalDensityFunction< FrequencyIterator, 
			    std::vector<unsigned int>::iterator >
  ( FrequencyStart, FrequencyEnd, Symbols.begin() );
};

#endif // EMPIRICAL_DENSITY_FUNCTION
